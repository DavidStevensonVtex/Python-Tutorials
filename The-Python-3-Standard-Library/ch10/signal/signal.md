# [Chapter 10: Concurrency with Processes, Threads, and Coroutines](https://pymotw.com/3/concurrency.html)

## [10.2 signal — Asynchronous System Events](https://pymotw.com/3/signal/index.html)

**Purpose:**	Asynchronous system events

Signals are an operating system feature that provide a means of notifying a program of an event, and having it handled asynchronously. They can be generated by the system itself, or sent from one process to another. Since signals interrupt the regular flow of the program, it is possible that some operations (especially I/O) may produce errors if a signal is received in the middle.

Signals are identified by integers and are defined in the operating system C headers. Python exposes the signals appropriate for the platform as symbols in the signal module. The examples in this section use SIGINT and SIGUSR1. Both are typically defined for all Unix and Unix-like systems.

Note

Programming with Unix signal handlers is a non-trivial endeavor. This is an introduction, and does not include all of the details needed to use signals successfully on every platform. There is some degree of standardization across versions of Unix, but there is also some variation, so consult the operating system documentation if you run into trouble.

### 10.2.1 Receiving Signals

As with other forms of event-based programming, signals are received by establishing a callback function, called a signal handler, that is invoked when the signal occurs. The arguments to the signal handler are the signal number and the stack frame from the point in the program that was interrupted by the signal.

```
# signal_signal.py
import signal
import os
import time


def receive_signal(signum, stack):
    print("Received:", signum)


# Register signal handlers
signal.signal(signal.SIGUSR1, receive_signal)
signal.signal(signal.SIGUSR2, receive_signal)

# Print the process ID so it can be used with 'kill'
# to send this program signals.
print("My PID is:", os.getpid())

while True:
    print("Waiting...")
    time.sleep(3)
```

This example script loops indefinitely, pausing for a few seconds each time. When a signal comes in, the sleep() call is interrupted and the signal handler receive_signal prints the signal number. After the signal handler returns, the loop continues.

Send signals to the running program using os.kill() or the Unix command line program kill.

```
$ python3 signal_signal.py
My PID is: 27086
Waiting...
Waiting...
Waiting...
Waiting...
Waiting...
Waiting...
Waiting...
Waiting...
Received: 10
Received: 12
Traceback (most recent call last):
  File "signal_signal.py", line 21, in <module>
    time.sleep(3)
KeyboardInterrupt
```

The previous output was produced by running signal_signal.py in one window, then in another window running:

```
$ pid=27086
$ kill -USR1 $pid
$ kill -USR2 $pid
$ kill -INT $pid
```

### 10.2.2 Retrieving Registered Handlers

To see what signal handlers are registered for a signal, use getsignal(). Pass the signal number as argument. The return value is the registered handler, or one of the special values SIG_IGN (if the signal is being ignored), SIG_DFL (if the default behavior is being used), or None (if the existing signal handler was registered from C, rather than Python).

```
# signal_getsignal.py
import signal


def alarm_received(n, stack):
    return


signal.signal(signal.SIGALRM, alarm_received)

signals_to_names = {
    getattr(signal, n): n for n in dir(signal) if n.startswith("SIG") and "_" not in n
}

for s, name in sorted(signals_to_names.items()):
    handler = signal.getsignal(s)
    if handler is signal.SIG_DFL:
        handler = "SIG_DFL"
    elif handler is signal.SIG_IGN:
        handler = "SIG_IGN"
    print("{:<10} ({:2d}):".format(name, s), handler)
```

Again, since each OS may have different signals defined, the output on other systems may vary. This is from Ubuntu 20.04:

```
$ python3 signal_getsignal.py
SIGHUP     ( 1): SIG_DFL
SIGINT     ( 2): <built-in function default_int_handler>
SIGQUIT    ( 3): SIG_DFL
SIGILL     ( 4): SIG_DFL
SIGTRAP    ( 5): SIG_DFL
SIGIOT     ( 6): SIG_DFL
SIGBUS     ( 7): SIG_DFL
SIGFPE     ( 8): SIG_DFL
SIGKILL    ( 9): SIG_DFL
SIGUSR1    (10): SIG_DFL
SIGSEGV    (11): SIG_DFL
SIGUSR2    (12): SIG_DFL
SIGPIPE    (13): SIG_IGN
SIGALRM    (14): <function alarm_received at 0x7f8e15637c10>
SIGTERM    (15): SIG_DFL
SIGCLD     (17): SIG_DFL
SIGCONT    (18): SIG_DFL
SIGSTOP    (19): SIG_DFL
SIGTSTP    (20): SIG_DFL
SIGTTIN    (21): SIG_DFL
SIGTTOU    (22): SIG_DFL
SIGURG     (23): SIG_DFL
SIGXCPU    (24): SIG_DFL
SIGXFSZ    (25): SIG_IGN
SIGVTALRM  (26): SIG_DFL
SIGPROF    (27): SIG_DFL
SIGWINCH   (28): SIG_DFL
SIGPOLL    (29): SIG_DFL
SIGPWR     (30): SIG_DFL
SIGSYS     (31): SIG_DFL
SIGRTMIN   (34): SIG_DFL
SIGRTMAX   (64): SIG_DFL
```

### 10.2.3 Sending Signals

The function for sending signals from within Python is os.kill(). Its use is covered in the section on the os module, [Creating Processes with os.fork()](https://pymotw.com/3/os/index.html#creating-processes-with-os-fork).

### 10.2.4 Creating Processes with os.fork()

The POSIX functions fork() and exec() (available under Mac OS X, Linux, and other Unix variants) are exposed via the os module. Entire books have been written about reliably using these functions, so check the library or bookstore for more details than are presented here in this introduction.

To create a new process as a clone of the current process, use fork():

```
# os_fork_example.py
import os

pid = os.fork()

if pid:
    print('Child process id:', pid)
else:
    print('I am the child')
```

The output will vary based on the state of the system each time the example is run, but it will look something like:

```
$ python3 -u os_fork_example.py
Child process id: 29053
I am the child
```

After the fork, there are two processes running the same code. For a program to tell which one it is in, it needs to check the return value of fork(). If the value is 0, the current process is the child. If it is not 0, the program is running in the parent process and the return value is the process id of the child process.

```
# os_kill_example.py
import os
import signal
import time


def signal_usr1(signum, frame):
    "Callback invoked when a signal is received"
    pid = os.getpid()
    print("Received USR1 in process {}".format(pid))


print("Forking...")
child_pid = os.fork()
if child_pid:
    print("PARENT: pid: ", os.getpid())
    print("PARENT: Pausing before sending signal...")
    time.sleep(1)
    print("PARENT: Signaling {}".format(child_pid))
    os.kill(child_pid, signal.SIGUSR1)
else:
    print("CHILD: pid: ", os.getpid())
    print("CHILD: Setting up signal handler")
    signal.signal(signal.SIGUSR1, signal_usr1)
    print("CHILD: Pausing to wait for signal")
    time.sleep(5)
```

The parent can send signals to the child process using kill() and the signal module. First, define a signal handler to be invoked when the signal is received. Then fork(), and in the parent pause a short amount of time before sending a USR1 signal using kill(). This example uses a short pause to give the child process time to set up the signal handler. A real application, would not need (or want) to call sleep(). In the child, set up the signal handler and go to sleep for a while to give the parent time to send the signal.

```
$ python3 -u os_kill_example.py
Forking...
PARENT: pid:  29598
PARENT: Pausing before sending signal...
CHILD: pid:  29599
CHILD: Setting up signal handler
CHILD: Pausing to wait for signal
PARENT: Signaling 29599
Received USR1 in process 29599
```

A simple way to handle separate behavior in the child process is to check the return value of fork() and branch. More complex behavior may call for more code separation than a simple branch. In other cases, there may be an existing program that needs to be wrapped. For both of these situations, the exec*() series of functions can be used to run another program.

```
# os_exec_example.py
import os

child_pid = os.fork()
if child_pid:
    os.waitpid(child_pid, 0)
else:
    os.execlp("pwd", "pwd", "-P")
```

When a program is run by exec(), the code from that program replaces the code from the existing process.

```
$ python3 os_exec_example.py
/home/dstevenson/Python/GitHub/Python-Tutorials/The-Python-3-Standard-Library/ch10/signal
```

There are many variations of exec(), depending on the form in which the arguments are available, whether the path and environment of the parent process should be copied to the child, etc. For all variations, the first argument is a path or filename and the remaining arguments control how that program runs. They are either passed as command line arguments or override the process “environment” (see os.environ and os.getenv). Refer to the library documentation for complete details.